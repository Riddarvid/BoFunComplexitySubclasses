

DecTree I:
  res : b -> DecTree I
  pick : (i : I) -> DecTree (I - i) -> DecTree (I - i) -> DecTree I

Min tro är att vi behöver ta med oss bijektionen som argument, eftersom vi måste ändra den från att ha typ I -> J till att ha typ (I -i) -> (J - (i2j i))



Definition av independent bits:

A function f : BF I does not depend on a set of variables U if it factors as f = f' . {0,1}^e, where e is an injection from I to I \\ U.



Bevis 1)

Vad vill vi visa?

Om f faktoriseras som f = f' . {0,1}^e, where e is an injection from I to J, (dvs. den är not dependent on I \\ J)

då har f och f' samma komplexitet.

Detta visar vi genom att först visa att varje decision tree för f, om vi mappar om det till ett träd av J (som representerar f'), har samma cost-funktion. 
Detta innebär att deras expected cost blir samma, vilket i sin tur betyder att komplexiteterna blir samma.

Bevis 2)

Vad vill vi visa?

Om f faktoriseras som f = f' . {0,1}^e, where e is a bijection from I to J, 

då har f och f' samma komplexitet.

Dvs. om vi för varje decision tree mappar om variablerna med en bijektion, kommer komplexiteten inte ändras.

Bevis 3)

Slutligen  behöver vi visa att vi faktiskt kan nyttja dessa egenskaper vid normalisering av BDDs. Vi måste visa att bortplockningen av index är injektiv, och sedan att omnumreringen är bijektiv.
Vi måste även visa att f faktoriserar på rätt sätt.


--------------------------------------------------

Bevis 1)

e är en injektion, dvs vi har i2j.

Antag f = mapBF i2j f' : BF J

där f' : BF I

Vill visa att för varje t : DecTree(J) sådant att decTreeSemantics t == f, så är decTreeSemantics t' == f' och expcost t == expcost t'
  where
    t' = mapDT e t : DecTree(I)



------------------------------------

Bevis 2

e bijektion
e = (i2j, j2i)

Antag att vi har en funktion f : BF I som faktoriserar som f = mapBF j2i f'

Pga. bijektion borde vi även ha f' = mapBF i2j f : BF J


Vi vill visa att för varje t : DecTree(I) sådant att decTreeSemantics t == f, så är decTreeSemantics t' == f' och expCost t == expCost t'
  where
    t' = mapDT e t : DecTree(J)

Egentligen kasnke vi snarare vill visa:
För varje t som representerar f, finns det ett träd t' som representerar f', sådant att t och t' har samma expected cost.
Detta borde ge att f' har komplexitet <= komplexiteten för f.

Om vi även lyckas visa andra riktningen, så får vi == istället för endast <=.


----------------------------------------------

Lemma 1: för varje t : DecTree(I) sådant att decTreeSemantics t == f, så är decTreeSemantics t' == f'

Vi vill visa att:

givet t : DecTree I
decTreeSemantics (mapDT i2j t) == mapBF i2j f

Induktionsbevis:

Basfall:

t :: DecTree I
t = Res b

f : BF I
f = decTreeSemantics t = Res b = \itup -> b

t' : DecTree J
t' = mapDT i2j t = mapDT i2j (Res b) = Res b

-- LHS
decTreeSemantics t' : BF J
decTreeSemantics t' = decTreeSemantics (Res b) = \jtup -> b 

-- RHS
f' = mapBF i2j f = \jtup -> f (comap i2j jtup) = \jtup -> (\itup -> b) (comap i2j jtup) | function application | \jtup -> b

LHS == RHS

Induktionsantagande: För träd av djup <= n gäller: decTreeSemantics t == f     =>    decTreeSemantics (mapDT i2j t) == mapBF i2j f   (med modifierad bijektion för att passa mängderna).

Antag att t är ett träd med djup n + 1. Då har t0 och t1 djup <= n.

t : DecTree I
t = Pick i t0 t1

f : BF I
f = decTreeSemantics t = decTreeSemantics (Pick i t0 t1) = \itup -> if itup i then decTreeSemantics t1 itup' else decTreeSemantics t0 itup'
  where
    t0, t1 :: DecTree (I - i)
    itup' :: (I - i) -> Bool
    itup' = itup

t' :: DecTree J
t' = Pick (i2j i) t0' t1'
  where
    t0', t1' :: DecTree (J - (i2j i))
    t0' = mapDT i2j t0 
    t1' = mapDT i2j t1

decTreeSemantics t' : BF J
decTreeSemantics t' = decTreeSemantics (Pick (i2j i) (mapDT i2j t0) (mapDT i2j t1)) = \jtup -> if jtup (i2j i)
  then decTreeSemantics (mapDT i2j t1) jtup'
  else decTreeSemantics (mapDT i2j t0) jtup'
  where
    jtup' : (J - (i2j i)) -> Bool


f' :: BF J
f' = mapBF i2j f = \jtup -> f (comap i2j jtup) = \jtup -> (\itup -> if itup i then decTreeSemantics t1 itup' else decTreeSemantics t0 itup') (comap i2j jtup) =
                                                   where 
                                                     itup' : (I - i) -> Bool
                                                     itup' = itup
   = \jtup -> if (comap i2j jtup) i then decTreeSemantics t1 itup' else decTreeSemantics t0 itup'
                                                   where 
                                                     itup' : (I - i) -> Bool
                                                     itup' = comap i2j jtup
   = \jtup -> if jtup (i2j i) 
  then decTreeSemantics t1 itup'
  else decTreeSemantics t0 itup'

Vi vill nu visa

\jtup -> if jtup (i2j i) then decTreeSemantics t1 (comap i2j jtup) else decTreeSemantics t0 (comap i2j jtup)

==

\jtup -> if jtup (i2j i) then decTreeSemantics (mapDT i2j t1) jtup else decTreeSemantics (mapDT i2j t0) jtup

Vi vill alltså visa 

decTreeSemantics t1 (comap i2j jtup) == decTreeSemantics (mapDT i2j t1) jtup

låt f1 : BF I 
    f1 = decTreeSemantics t1

LHS =
decTreeSemantics t1 (comap i2j jtup) =
decTreeSemantics t1 (jtup . i2j) =
f1 (jtup . i2j)

Enligt induktionsantagandet har vi

decTreeSemantics (mapDT i2j t1) 
= mapBF i2j f1

RHS =
decTreeSemantics (mapDT i2j t1) jtup = 
(mapBF i2j f1) jtup =
(\tup -> f1 (comap i2j tup)) jtup =
f1 (comap i2j jtup) =
f1 = (jtup . i2j)

Vi har visat LHS == RHS och är därmed klara.


---------------------------------------------------------

Lemma 2: för varje t : DecTree(I) sådant att det representerar f och t' = (mapDT e t) : DecTree(J), så är cost t (tup . e) == cost t' tup

Induktionsbevis.

Basfall: 

t = t' = Res b
cost t (tup . e) == cost t' tup

Induktionsantagande: För träd av djup <= n gäller cost t == cost t'.

Antag att t är ett träd med djup n + 1. Då har t0 och t1 djup <= n och alltså gäller cost t0 == cost t0' och cost t1 == cost t1'.

t = Pick i t0 t1
t' = Pick (e i) t0' t1'
  where
    t0' = mapDT e t0
    t1' = mapDT e t1



cost t (jtup . e) = cost (Pick i t0 t1) (jtup . e) = 1 + if (jtup . e) i then cost t1 itup' else cost t0 itup'
  where
    itup' = (jtup . e) restricted

cost t' jtup = cost (Pick (e i) t0' t1') = 1 + if jtup (e i) then cost t1' jtup' else cost t0' jtup'
  where
    jtup' = jtup (men med restrictad typ), dvs domänen för jtup' är mindre än den för jtup.

Induktionsantagande: För små träd (med djup n) gäller cost t == cost t'.


--------------------- Utilities -----------------------------

-- Given a probability p and a dectree, gives the polynomial representing the expected cost.
expCost : Rational -> DecTree I -> Poly Rational
expCost _ (Res b) = 0
expCost p (Pick i tF tT) = 1 + p * expCost tT + (1 - p) * expCost tF

The normal cost function:
cost (Res _) _ = 0
cost (Pick i t0 t1) tup = 1 + if tup i then cost t1 tup' else cost t0 tup'
  where
    tup' = tup men med restrictad domän.


mapDT (I -> J) -> DecTree I -> DecTree J
mapDT _ (Res b) = Res b
mapDT i2j (Pick i t1 t2) = Pick (i2j i) (mapDT i2j' t1) (mapDT i2j' t2)
  where
    i2j' = ändra typen på något sätt till (I - i) -> (J - (i2j i))

decTreeSemantics : DecTree(I) -> BF I
decTreeSemantics (Res b) _ = b
decTreeSemantics (Pick i t0 t1) tup = if tup i
  then decTreeSemantics t1 tup'
  else decTreeSemantics t0 tup'
  where
    tup' : (I - i) -> Bool
    tup' = tup (does this work, type wise?)

mapBF : (i->j) -> BF i -> BF j
mapBF i2j f = \jtup -> f (comap i2j jtup)

comap :: (i->j) -> Tup j -> Tup i
comap i2j tup = \i -> tup (i2j i)
comap i2j tup = tup . i2j
















------------------------

Vad betyder det att ha en injektiv funcktion e?
Då måste |I| vara <= |J|

I: {1, 2, 3}
J: {1, 79, 32, 41}

e : I -> J
e 1 = 1
e 2 = 79
e 3 = 41

e har nu gjort att vi plockar bort bit 32 från J och har mappat om övriga variabler till {1,2,3}.

g = comap e g'

--------------------------------

Later in the paper, we will want to re-map variables. If a function can be composed as f = mapBF i2j f', where
i2j is an injective function, then f and f' will have the same complexity. This is useful, since
it allows us to replace any f with f' instead, leading to a normalization of functions, making it so that
memoization can be better utilized.

Proof:

Antag 

fj : BF J, 
fi : BF I,
i2j : I -> J

fj = mapBF i2j fi

Vi kan nu börja med att visa att vi för varje tj sådant att [tj] = fj, så kan vi skapa ett ti sådant att [ti] = fi,
och expCost tj == expCost ti. Eftersom vi för varje tj kan skapa ti med samma exp cost har vi D_p(fi) <= D_p(fj).

Sedan kan vi prova att visa att vi för varje ti sådan att [ti] = fi kan skapa ett tj sådant att [tj] = fj och 
expcost tj == expcost ti. Då får vi D_p(fi) >= D_p(fj).

Kombinerar vi dessa två får vi D_p(fi) == D_p(fj).

Vi bevisar nu de två delarna:

1)

Givet att fj = mapBF i2j fi, visa

([tj] = fj <=> [ti] = fi) och (expCost tj == expCost ti), där tj = mapDT i2j ti.

Vi behöver alltså visa tre saker:

1) [tj] = fj => [ti] = fi
2) [ti] = fi => [tj] = fj
3) expCost tj == expCost ti

Bevis av 1)

Antag [tj] = fj.

Vi vill visa [ti] = fi.

De satser vi har tillgång till är:
- [tj] = fj (antagande)
- tj = mapDT i2j ti (premiss)
- fj = mapBF i2j fi (premiss)

Fundering: Är det okej att utföra en injektiv operation bå båda sidor?

Ja!

f injektiv betyder att om f(x) == f(y) så måste x == y

Vi kan alltså visa [ti] = fi genom att visa att mapBF i2j [ti] == mapBF i2j fi

(Behöver även bekräfta/bevisa att mapBF i2j är injektiv då i2j är injektiv).

Vi använder induktionsbevis.

Basfall: tj = Res b
Detta ger:
fj = [tj] = [Res b] = \x -> b

tj = mapDT i2j ti
Res b = mapDT i2j ti
Res b = ti -- Detta steg är lite osäkert.

LHS = 
mapBF i2j [ti] = {can be proved by def of mapBF. Fråga Patrik om detta är okej.}
mapBF i2j (Res b)

RHS =
mapBF i2j fi = {def fj}
fj

-- Det är fortfarande något som inte går ihop.

Bevis av 2)

Antag [ti] = fi.

Vill visa [tj] = fj.

De satser vi har tillgång till är:
- [ti] = fi (antagande)
- tj = mapDT i2j ti (premiss)
- fj = mapBF i2j fi (premiss)

Basfall: ti = Res b
Detta ger:
fi = [ti] = [Res b] = \x -> b

LHS =
[tj] =
[mapDT i2j ti] =
[mapDT i2j (Res b)] =
[Res b] =
\x -> b

RHS =
fj =
mapBF i2j fi =
\jtup -> fi (comap i2j jtup) =
\jtup -> (\x -> b) (comap i2j jtup)
\jtup -> b = {variable substitution}
\x -> b

Induktionsantagande: Då depth(ti) <= n så gäller [ti] = fi => [tj] = fi

Vill visa att Då depth(ti) = n + 1 så gäller [ti] = fi => [tj] = fi

Antag depth(ti) = n + 1
Detta innebär, enligt definitionen av depth, att ti måste ha följande form:
ti = Pick i tif tit, där depth(tif) <= n och depth(tit) <= n.

Detta ger

fi = 
[ti] =
Pick i tif tit = 
\tup -> if tup i
  then decTreeSemantics tif tup
  else decTreeSemantics tit tup

tj = 
mapDT i2j ti =
mapDT i2j (Pick i tif tit) =
Pick (i2j i) (mapDT i2j tif) (mapDT i2j tit)

LHS =
[tj] =
[Pick (i2j i) (mapDT i2j tif) (mapDT i2j tit)] = 
\jtup -> if jtup (i2j i)
  then decTreeSemantics (mapDT i2j tif) jtup
  else decTreeSemantics (mapDT i2j tit) jtup

RHS =
fj =
mapBF i2j fi =
mapBF i2j (\tup -> if tup i
  then decTreeSemantics tif tup
  else decTreeSemantics tit tup) =
\jtup -> (\tup -> if tup i
  then decTreeSemantics tif tup
  else decTreeSemantics tit tup) (comap i2j jtup) =
\jtup -> if (comap i2j jtup) i
  then decTreeSemantics tif (comap i2j jtup)
  else decTreeSemantics tit (comap i2j jtup) =
\jtup -> if jtup (i2j i)
  then decTreeSemantics tif (comap i2j jtup)
  else decTreeSemantics tit (comap i2j jtup)

Vi behöver nu visa
[(mapDT i2j tif)] jtup = [tif] (comap i2j jtup)










---------------------------------------------

g = g' . i2j

g : Input av typ J
g' : Input av typ I
i2j injektiv funktion från I till J -> |I| <= |J| 

Vi vill gå från ett DT av J till ett DT av I. Det är tillåtet att skapa ett träd med strikt lägre komplexitet.

mapDTinverse :: (I -> J) -> DT J -> DT I
mapDTinverse _ (Res b) = Res b
mapDTinverse i2j (pick j t1 t2)
  | j in image of i2j = pick (inverse i2j j) (mapDTinverse i2j t1) (mapDTinverse i2j t2)
  | otherwise = mapDTinverse i2j t1

Vi skulle kunna behöva ett extra bevis som säger att om j inte är i bilden av i2j så måste
de båda sub-funktionerna vara identiska.

Bevis:

Givet en funktion gj = mapBFinput i2j gi och ett dt tj sådant att gj = [tj], samt en injektiv funktion i2j,
visa att [mapDTinverse i2j tj] = gi.

Visa även att mapDTinverse i2j tj har strikt lägre än eller samma kostnad som ti.

Induktionsbevis.

Basfall: 

tj = Res b

LHS =
[mapDTinverse i2j tj] =
[Res b] =
\itup -> b

RHS =
gi =

-------------------------------

För varje BF g : BF I och varje bijektion e mellan I och J
kommer funktionen g' = mapBF e g ha samma komplexitet som g.

e . (inv e) = id
mapBF e . mapBF (inv e) == id

mapBF e bf = \inputtup -> bf (inputtup . e)


mapBF e f inputtup = f (inputtup . e)